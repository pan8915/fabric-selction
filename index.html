<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - geometry hierarchy</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			background: #fff;
			padding: 0;
			margin: 0;
			font-weight: bold;
			overflow: hidden;
		}
	</style>
</head>

<body>
	<script src="https://code.jquery.com/jquery-3.2.1.js" integrity="sha256-DZAnKJ/6XZ9si04Hgrsxu/8s717jcIzLy3oi35EouyE=" crossorigin="anonymous"></script>
	<script src="three.min.js"></script>
	<script src="stats.min.js"></script>
	<script src="Projector.js"></script>
	<script src="CanvasRenderer.js"></script>
	<script src="tween.min.js"></script>
	<script src="Detector.js"></script>
 <script src="https://code.jquery.com/jquery-1.10.2.js"></script>
	<script>
		var container, stats;
		var camera, scene, renderer;
		var geometry, group, fabrics;
		var fabrics = [];
    var intersection=null;
		var mouseX = 0,
			mouseY = 0;
		var windowHalfX = window.innerWidth / 5;
		var windowHalfY = window.innerHeight / 5;
		var dirLight, hemiLight, spotLight, cloth, textureLoader, raycaster, mouse;

		init();
		animate();

		function init() {
			container = document.createElement('div');
			document.body.appendChild(container);
			camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 8000);
			camera.position.z = 500;
			group = new THREE.Group();
			scene = new THREE.Scene();
			scene.fog = new THREE.Fog(0xffffff, 1, 10000);
			//fabric json
			$.getJSON("texture.json", function(data) {
				for (var i = 0; i < 39; i++) {
					var textureLoader = new THREE.TextureLoader();
					var geometry = new THREE.BoxGeometry(100, 100, 1);
					var texture = textureLoader.load('image/' + data.filename[i]);
					var material = new THREE.MeshBasicMaterial({
						map: texture
					});

					// var faceMaterial = new THREE.MeshFaceMaterial(materials);
					var mesh = new THREE.Mesh(geometry, material);
					mesh.position.x = Math.random() * 900 - 300;
					mesh.position.y = Math.random() * 900 - 300;
					mesh.position.z = Math.random() * 900 - 300;
					mesh.rotation.x = Math.random() * 2 * Math.PI;
					mesh.rotation.y = Math.random() * 2 * Math.PI;
					mesh.matrixAutoUpdate = false;
					mesh.updateMatrix();
					group.add(mesh);
					fabrics.push(mesh);
				}
				scene.add(group);
			});

			raycaster = new THREE.Raycaster();
			mouse = new THREE.Vector2();

			renderer = new THREE.WebGLRenderer();
			renderer.setClearColor(0xffffff);
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			// renderer.sortObjects = false;
			container.appendChild(renderer.domElement);
			//document.addEventListener('mousedown', onDocumentMouseDown, false);
			document.addEventListener('mousemove', onDocumentMouseDown, false);
			document.addEventListener('touchstart', onDocumentTouchStart, false);
			window.addEventListener('resize', onWindowResize, false);

			// textureLoader = new THREE.TextureLoader();
			// var clothWidth = 4;
			// var clothHeight = 3;
			// var clothNumSegmentsZ = clothWidth * 5;
			// var clothNumSegmentsY = clothHeight * 5;
			// var clothSegmentLengthZ = clothWidth / clothNumSegmentsZ;
			// var clothSegmentLengthY = clothHeight / clothNumSegmentsY;
			// var clothPos = new THREE.Vector3(-3, 3, 2);
			// var clothGeometry = new THREE.PlaneBufferGeometry(clothWidth, clothHeight, clothNumSegmentsZ, clothNumSegmentsY);
			// clothGeometry.rotateY(Math.PI * 0.5);
			// clothGeometry.translate(clothPos.x, clothPos.y + clothHeight * 0.5, clothPos.z - clothWidth * 0.5);
			// var clothMaterial = new THREE.MeshLambertMaterial({
			// 	color: 0xcccccc,
			// 	side: THREE.DoubleSide
			// });
			// var cloth = new THREE.Mesh(clothGeometry, clothMaterial);
			// cloth.castShadow = true;
			// cloth.receiveShadow = true;
			// scene.add(cloth);
			// textureLoader.load("image/sontte1.png", function(texture) {
			// 	texture.wrapS = THREE.RepeatWrapping;
			// 	texture.wrapT = THREE.RepeatWrapping;
			// 	texture.repeat.set(clothNumSegmentsZ, clothNumSegmentsY);
			// 	cloth.material, map = texture;
			// 	cloth.material.needsUpdate = true;
			// });
			function onWindowResize() {
  			camera.aspect = window.innerWidth / window.innerHeight;
  			camera.updateProjectionMatrix();
  			renderer.setSize(window.innerWidth, window.innerHeight);
  		}

			function onDocumentTouchStart( event ) {
				event.preventDefault();
				event.clientX = event.touches[0].clientX;
				event.clientY = event.touches[0].clientY;
				onDocumentMouseDown( event );
			}

  		function onDocumentMouseDown(event) {

  			mouseX = (event.clientX - windowHalfX) * 2;
  			mouseY = (event.clientY - windowHalfY) * 2;
        event.preventDefault();
  			mouse.x = +( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
  			raycaster.setFromCamera(mouse, camera);
  			var intersections = raycaster.intersectObjects(group.children);
        intersection = (intersections.length)>0 ? intersections[0]:null;
  			if (intersection) {
         for (var i=0; i<intersections.length; i++){
         var intersection = intersections[i],
         obj = intersection.object;
          console.log('I am here');
          obj.material.color.setRGB(1.0-i/intersections.length,0,0);
         }
  			}
  		}
		}
		//
		function animate() {
			requestAnimationFrame(animate);
			render();
			//stats.update();
		}

		function render() {
      TWEEN.update();
			camera.position.x += (mouseX - camera.position.x) * .02;
			camera.position.y += (-mouseY - camera.position.y) * .02;
			camera.lookAt(scene.position);
      var time = Date.now();
			scene.rotation.x = Math.sin(time * 0.0002) * 0.9;
			scene.rotation.y = Math.sin(time * 0.0002) * 0.9;
			scene.rotation.z = Math.sin(time * 0.0002) * 0.9;
			renderer.render(scene, camera);
		}
	</script>

</body>

</html>
